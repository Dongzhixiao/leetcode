# -*- coding: utf-8 -*-
"""
Created on Sat Jun 27 10:22:30 2020

@author: 34791
有 N 层的楼，给你 K 个鸡蛋（K 至少为 1）。
现在确定这栋楼存在楼层 0 <= F <= N，在这层楼将鸡蛋扔下去，
鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。
现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？
注意：
1.理解什么叫做「最坏情况」下了，鸡蛋破碎一定发在搜索区间穷尽时
2.来理解什么叫「至少」要扔几次
"""
memo = dict()
#定义函数： N 层的楼，给你 K 个鸡蛋， 最坏情况下，至少要扔鸡蛋的次数
def eggThrow(K,N):    
    #基本情况
    if K == 1:
        return N
    if N == 0:
        return 0
    if (K,N) in memo:
        return memo[(K,N)]
    res = N #代表无穷大
    for i in range(1,N+1):
        res = min(res,max(eggThrow(K-1,i-1),eggThrow(K,N-i))+1)
    memo[(K,N)] = res 
    return res

t = eggThrow(3,5)

#这个算法的时间复杂度是多少呢？动态规划算法的时间复杂度就是子问题个数 × 函数本身的复杂度。
#函数本身的复杂度就是忽略递归部分的复杂度，这里dp 函数中有一个 for循环，所以函数本身的复杂度是 O(N)。
#子问题个数也就是不同状态组合的总数，显然是两个状态的乘积，也就是O(KN)。
#所以算法的总时间复杂度是 O(K*N^2), 空间复杂度 O(KN)。